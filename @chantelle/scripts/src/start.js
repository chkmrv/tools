/* eslint fp/no-mutation:0, better/no-new:0, no-console:0, fp/no-unused-expression:0, better/no-ifs:0 */
import { env } from '@chantelle/config'
import fs from 'fs'
import chalk from 'chalk'
import webpack from 'webpack'
import WebpackDevServer from 'webpack-dev-server'
import clearConsole from 'react-dev-utils/clearConsole'
import checkRequiredFiles from 'react-dev-utils/checkRequiredFiles'
import {
  choosePort,
  createCompiler,
  prepareProxy,
  prepareUrls,
} from 'react-dev-utils/WebpackDevServerUtils'
import openBrowser from 'react-dev-utils/openBrowser'
import { paths } from '@chantelle/config'
import { webpackDevelopmentConfig as config } from '@chantelle/config'
import { debug, thrower } from '@chantelle/util'
import { createDevServerConfig } from '@chantelle/config'

const { appPublic, appHtml, appIndexJs, appPackageJson, yarnLockFile } = paths

export const runStart = () => {
  // Do this as the first thing so that any code reading it knows the right env.
  // process.env.BABEL_ENV = 'development'
  // process.env.NODE_ENV = 'development'

  // Makes the script crash on unhandled rejections instead of silently
  // ignoring them. In the future, promise rejections that are not handled will
  // terminate the Node.js process with a non-zero exit code.
  process.on('unhandledRejection', thrower)

  const isInteractive = process.stdout.isTTY
  const { DISABLE_OPEN_BROWSER, DISABLE_CLEAR_TERMINAL } = env
  const useYarn = fs.existsSync(yarnLockFile)

  // Warn and crash if required files are missing
  if (!checkRequiredFiles([appHtml, appIndexJs])) {
    process.exit(1)
  }

  // Tools like Cloud9 rely on this.
  const DEFAULT_PORT = debug(parseInt(env.PORT, 10) || 3000, 'PORT')
  const HOST = debug(env.HOST || '0.0.0.0', 'HOST')

  // We attempt to use the default port but if it is busy, we offer the user to
  // run on a different port. `detect()` Promise resolves to the next free port.
  return choosePort(HOST, DEFAULT_PORT)
    .then(port => {
      if (port == null)
        // We have not found a port.
        return false
      const protocol = env.HTTPS === true ? 'https' : 'http'
      const appName = require(appPackageJson).name
      debug('prepareUrls for %O', {
        protocol,
        HOST,
        port,
      })
      const urls = debug(prepareUrls(protocol, HOST, port), 'urls %O')
      // Create a webpack compiler that is configured with custom messages.
      const compiler = createCompiler(webpack, config, appName, urls, useYarn)
      // Load proxy config
      const proxySetting = require(appPackageJson).proxy
      const proxyConfig = prepareProxy(proxySetting, appPublic)

      // Serve webpack assets generated by the compiler over a web sever.
      const serverConfig = createDevServerConfig(
        proxyConfig,
        urls.lanUrlForConfig,
      )

      const devServer = new WebpackDevServer(compiler, serverConfig)

      // Launch WebpackDevServer.
      devServer.listen(port, HOST, err => {
        if (err) return console.log(err)

        if (isInteractive && DISABLE_CLEAR_TERMINAL !== true) clearConsole()

        //eslint-disable-next-line no-console
        console.log(chalk.cyan('Starting the development server...\n'))
        return DISABLE_OPEN_BROWSER === true
          ? //eslint-disable-next-line no-console
            console.info(urls.localUrlForBrowser)
          : openBrowser(urls.localUrlForBrowser)
      })

      return devServer
    })
    .then(devServer =>
      ['SIGINT', 'SIGTERM'].forEach(sig =>
        process.on(sig, () => [devServer.close(), process.exit()]),
      ),
    )
    .catch(err => [
      //eslint-disable-next-line no-console
      console.error(err),
      process.exit(1),
    ])
}

export default runStart
